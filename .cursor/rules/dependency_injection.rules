# Dependency Injection Rules
# Scope: All Python files in the project
# Dependencies: None
# Related Rules: testing.rules (depends on these rules)

# Rule: Classes should accept dependencies through their constructors
rule "DI_ConstructorInjection" {
    when {
        # Look for class definitions
        class_def = class {
            # Check if constructor exists
            constructor = method {
                # Constructor should have parameters
                params = parameters
                # Parameters should be used to set instance variables
                body = method_body {
                    # Look for assignments to instance variables
                    assignments = assignment {
                        # Left side should be an instance variable
                        left = instance_variable
                        # Right side should be a parameter
                        right = parameter
                    }
                }
            }
        }
    }
    message "Classes should accept dependencies through their constructors for better testability"
    severity warning
}

# Rule: Avoid direct instantiation of dependencies
rule "DI_NoDirectInstantiation" {
    when {
        # Look for new expressions
        new_expr = new {
            # Inside a method body
            parent = method_body
            # Not in a constructor
            not parent.parent = constructor
        }
    }
    message "Avoid direct instantiation of dependencies. Pass them through constructors instead."
    severity warning
}

# Rule: Use interfaces/abstract classes for dependencies
rule "DI_UseInterfaces" {
    when {
        # Look for class definitions
        class_def = class {
            # That have constructor parameters
            constructor = method {
                params = parameters
                # Parameters should be of interface/abstract type
                param_types = parameter_types
                not param_types = concrete_class
            }
        }
    }
    message "Consider using interfaces or abstract classes for dependencies to improve testability"
    severity suggestion
}

# Rule: Make dependencies explicit
rule "DI_ExplicitDependencies" {
    when {
        # Look for class definitions
        class_def = class {
            # That have instance variables
            instance_vars = instance_variable
            # But no constructor parameters
            not constructor = method {
                params = parameters
            }
        }
    }
    message "Make dependencies explicit by passing them through constructors"
    severity warning
}

# Rule: Avoid static dependencies
rule "DI_NoStaticDependencies" {
    when {
        # Look for static method calls
        static_call = method_call {
            # That are not utility functions
            not method_name = utility_method
        }
    }
    message "Avoid static dependencies. Pass them through constructors instead."
    severity warning
}

# Rule: Testability annotations
rule "DI_TestabilityDocs" {
    when {
        # Look for class definitions
        class_def = class {
            # Without testability documentation
            not docstring = docstring {
                contains "test"
                or contains "mock"
                or contains "dependency"
            }
        }
    }
    message "Consider adding documentation about how to test this class and its dependencies"
    severity suggestion
}

# Rule: Dependency validation
rule "DI_ValidateDependencies" {
    when {
        # Look for constructors
        constructor = method {
            # Without null checks
            params = parameters
            not body = method_body {
                contains "if"
                and contains "null"
            }
        }
    }
    message "Consider validating dependencies in constructors"
    severity suggestion
}

# Rule: Optional dependencies
rule "DI_OptionalDependencies" {
    when {
        # Look for constructor parameters
        param = parameter {
            # That are required
            not optional = true
            # But could be optional
            type = interface
            or type = abstract_class
        }
    }
    message "Consider making this dependency optional if it's not always needed"
    severity suggestion
}

# Rule: Dependency lifecycle
rule "DI_LifecycleManagement" {
    when {
        # Look for classes
        class_def = class {
            # That implement IDisposable
            implements = "IDisposable"
            # But don't dispose dependencies
            not dispose = method {
                contains "dispose"
                and contains "dependency"
            }
        }
    }
    message "Consider disposing of dependencies in the Dispose method"
    severity warning
}

# Rule: Circular dependencies
rule "DI_NoCircularDeps" {
    when {
        # Look for class definitions
        class_a = class {
            # That depend on class B
            depends_on = class_b
            # And class B depends on class A
            class_b = class {
                depends_on = class_a
            }
        }
    }
    message "Avoid circular dependencies. Consider using an interface or event-based communication."
    severity error
} 
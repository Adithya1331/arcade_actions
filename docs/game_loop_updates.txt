Looking at the Cocos2D programming guide (where these Actions were translated from) gives additional insight into the design choices about game loop vs normalized time. https://los-cocos.github.io/cocos-site/doc/programming_guide/actions.html

Particularly this section:
def step(self, dt):
    # dt is time that elapsed from last tick in seconds
    # update position
    self.position = self.position + dt * self.velocity

I can see the design philosophy better now. The idea is that:

1. Game loop time (dt) represents how much time has actually passed since the last frame
2. Actions internally track their total elapsed time and convert it to a normalized 0-1 space
3. This conversion happens in step() specifically so that:
   * Individual actions only need to think in terms of "what position should I be at X% through the animation?"
   * The step() method handles all the "what portion of the duration has elapsed?" logic
   * And critically, this means actions work correctly even if frame rates vary

So while it may seem like an awkward marriage, it's actually a deliberate separation of concerns:

* The game loop just tells actions "this much time has passed"
* The action's step() method converts that to "this is what percentage through the animation we are"
* The action's update() method just needs to know "at X% through, what state should I be in?"

Based on the code shown, here's how a basic game loop would look to update actions:

class MyGame(arcade.Window):
    def __init__(self):
        super().__init__(800, 600, "Game")
        self.active_actions = []
        self.sprite = arcade.Sprite(...)  # Your sprite setup
        
    def start_some_action(self):
        # Example of starting actions in response to an event
        action = MoveTo((100, 100), 2.0) + RotateBy(360, 1.0)
        action.target = self.sprite
        action.start()
        self.active_actions.append(action)

    def update(self, delta_time: float):  # Game loop, called every 1/60 sec
        # Update all active actions
        for action in self.active_actions[:]:  # Copy list since we'll modify it
            action.step(delta_time)
            if action.done():
                action.stop()
                self.active_actions.remove(action)

Though looking at the code, you could also use the built-in ActionSprite class which already handles this pattern:

class MyGame(arcade.Window):
    def __init__(self):
        super().__init__(800, 600, "Game")
        self.sprite = ActionSprite(...)  # Uses the action-aware sprite class
        
    def start_some_action(self):
        action = MoveTo((100, 100), 2.0) + RotateBy(360, 1.0)
        self.sprite.do(action)  # Sprite handles tracking the action

    def update(self, delta_time: float):
        self.sprite.update(delta_time)  # Handles action updates internally

The ActionSprite approach is probably cleaner since it encapsulates all the action management within the sprite itself rather than having to track actions separately.

ActionSprites in an Arcade 3.x SpriteList can be used for more efficient updates, a way to move a whole group of enemies together with the same actions. Think Space Invaders where whole lines of aliens march back and forth across the screen and slowly work their way downwards towards the player.

The ActionSprite class inherits from arcade.Sprite, so it's fully compatible with SpriteList. For the Space Invaders style movement, here's how you could structure it:

class Game(arcade.Window):
    def __init__(self):
        super().__init__(800, 600, "Space Invaders Style")
        
        # Create sprite list for enemies
        self.enemies = arcade.SpriteList()
        
        # Create a grid of enemies
        for row in range(5):
            for col in range(10):
                enemy = ActionSprite("enemy.png", 0.5)
                enemy.center_x = 100 + col * 60
                enemy.center_y = 500 - row * 50
                self.enemies.append(enemy)
        
        # Create the marching movement pattern
        self.setup_enemy_movement()

    def setup_enemy_movement(self):
        # Create a sideways march + drop pattern
        march_right = MoveBy((100, 0), 2.0)
        march_left = MoveBy((-100, 0), 2.0)
        drop_down = MoveBy((0, -20), 0.5)
        
        # Combine into a repeating sequence
        movement = march_right + drop_down + march_left + drop_down
        repeated_movement = Repeat(movement)
        
        # Apply to all enemies
        for enemy in self.enemies:
            enemy.do(repeated_movement)

    def update(self, delta_time: float):
        # Update all sprites in the list
        self.enemies.update(delta_time)  # This calls update() on each sprite

    def on_draw(self):
        self.clear()
        self.enemies.draw()

Key points:
* SpriteList will handle calling update() on each sprite efficiently
* All enemies will move in sync since they're started with the same action sequence at the same time
* The Repeat action keeps them moving indefinitely
* You still get the benefit of the action system's timing and sequencing

You could even add variety by:
* Using Spawn to combine movement with other actions (like rotation or scaling)
* Adding slight delays between rows using RandomDelay
* Creating different patterns for different rows
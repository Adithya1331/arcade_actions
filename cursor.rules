{
  "mandatory_consultation": {
    "before_code_changes": {
      "primary_requirements": "docs/prd.md - Architectural foundation, requirements, and code quality standards",
      "implementation_guide": "docs/api_usage_guide.md - Primary implementation guide for all component usage",
      "testing_hub": "docs/testing_index.md - Central hub for all testing-related documentation",
      "rule": "ALWAYS consult these documents before making significant code changes or architectural decisions",
      "workflow": [
        "1. Check PRD.md for architectural constraints and quality standards",
        "2. Review api_usage_guide.md for implementation patterns and component usage",
        "3. Consult testing_index.md to find appropriate testing documentation",
        "4. Follow testing_index.md links to specific testing guides (testing.md, etc.)"
      ]
    }
  },
  "project_structure": {
    "source_code": {
      "path": "actions/",
      "description": "Main project source code for ArcadeActions - contains the implementation of the Actions system"
    },
    "reference_code": {
      "path": "references/arcade/",
      "description": "Reference implementation from Arcade 3.x - used for understanding how to interface with Arcade's systems"
    },
    "tests": {
      "path": "tests/",
      "description": "Unit and integration tests for the Actions system"
    },
    "docs": {
      "path": "docs/",
      "description": "Project documentation"
    }
  },
  "relationships": {
    "actions_to_arcade": {
      "description": "The Actions system in actions/ directory interfaces with Arcade 3.x functionality referenced in references/arcade/",
      "source": "actions/",
      "reference": "references/arcade/"
    }
  },
  "core_design_principles": {
    "interface_design": {
      "zero_tolerance_rule": "ZERO TOLERANCE for runtime type/attribute checking (hasattr, getattr, isinstance, EAFP-with-pass)",
      "rationale": "Design interfaces so checking isn't needed. Unclear interfaces are the real problem, not the checking pattern.",
      "required_approach": [
        "Consistent base interfaces with default values",
        "Clear protocols guaranteeing expected methods/attributes",
        "Composition patterns eliminating optional attributes",
        "Unified interfaces for similar objects (Action vs GroupAction)"
      ]
    },
    "error_handling": {
      "eafp_rule": "EAFP only for genuine decision points with real fallback logic, NEVER for error silencing",
      "forbidden": "except AttributeError: pass - this is a code smell",
      "acceptable": "except AttributeError: return default_value  # genuine fallback"
    }
  },
  "api_usage_patterns": {
    "sprite_types": {
      "ActionSprite": "REQUIRED for all sprites that use actions. Only ActionSprite supports the Actions system.",
      "arcade.Sprite": "NOT compatible with Actions. Use only for sprites that don't need action-based behavior."
    },
    "group_management": {
      "SpriteGroup": "Use for coordinated group behavior. Extends arcade.SpriteList with automatic GroupAction management.",
      "GroupAction": "Created automatically by SpriteGroup.do(). Rarely created directly.",
      "arcade.SpriteList": "Use only for sprites that don't need coordinated actions."
    },
    "boundary_interactions": {
      "BoundedMove_individual": "Apply to individual ActionSprite for simple bouncing behavior.",
      "BoundedMove_group": "Apply to SpriteGroup for coordinated group bouncing (Space Invaders pattern). Only edge sprites trigger callbacks.",
      "WrappedMove": "Apply to individual sprites or groups for screen wrapping behavior."
    },
    "common_patterns": {
      "individual_control": "ActionSprite.do(action) for single sprite behaviors",
      "group_coordination": "SpriteGroup.do(action) for synchronized group movements",
      "collision_detection": "SpriteGroup.on_collision_with() for efficient group collisions",
      "boundary_detection": "BoundedMove + SpriteGroup for formation-style movement with edge detection"
    },
    "testing_patterns": {
      "individual_actions": "Use ActionSprite fixtures, test with sprite.do() and sprite.update()",
      "group_actions": "Use SpriteGroup fixtures, verify GroupAction creation and automatic cleanup",
      "boundary_actions": "Test edge detection, callback coordination, and spacing preservation",
      "collision_detection": "Test SpriteGroup collision handlers and method chaining",
      "comprehensive_guide": "See docs/testing_index.md for complete testing patterns, fixtures, and mock usage guidelines"
    }
  }
} 